// [개선] 유지보수를 위해 스프레드시트 ID와 시트 이름을 상수로 관리합니다.
const SPREADSHEET_ID = '1Ke5jewImhcCk_oHh0kLH3qr99WEGamnDqPmflnCdgQU';
const SHEET_NAMES = {
  USER_DATA: '주사위 시뮬레이터 데이터',
  DICE_SETTING: 'DiceSetting'
};

// [개선] GET 요청을 처리하는 중앙 라우터 역할을 합니다.
function doGet(e) {
  try {
    const action = e.parameter.action;
    const callback = e.parameter.callback;
    let result;

    switch (action) {
      case 'loadUser':
        result = loadUserData(e.parameter.userId);
        break;
      case 'updateUser': // GET 요청으로 update를 하는 것은 권장되지 않지만, 기존 로직을 유지합니다.
        result = updateUserData(e.parameter);
        break;
      case 'loadDiceSettings':
        result = loadDiceSettings(e.parameter.userId);
        break;
      case 'updateRollEnable': // GET 요청으로 update를 하는 것은 권장되지 않지만, 기존 로직을 유지합니다.
        result = updateRollEnable(e.parameter);
        break;
      case 'updateDiceSlot': // 새로운 액션 추가 - 주사위 슬롯 업데이트
        result = updateDiceSlot(e.parameter);
        break;
      default:
        // 유효하지 않은 action일 경우, 에러 객체를 생성합니다.
        result = { status: 'error', message: 'Invalid action' };
        break;
    }
    
    // [개선] JSON / JSONP 응답 처리를 함수로 분리하여 중복을 제거합니다.
    return createJsonResponse(result, callback);

  } catch (error) {
    const errorResponse = { status: 'error', message: error.toString(), stack: error.stack };
    return createJsonResponse(errorResponse, e.parameter.callback);
  }
}

// [개선] POST 요청을 처리하는 중앙 라우터 역할을 합니다.
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    let result;

    switch (data.action) {
      case 'loadUser':
        result = loadUserData(data.userId);
        break;
      case 'updateUser':
        result = updateUserData(data);
        break;
      case 'loadDiceSettings':
        result = loadDiceSettings(data.userId);
        break;
      case 'updateRollEnable':
        result = updateRollEnable(data);
        break;
      case 'updateDiceSlot': // 새로운 액션 추가 - 주사위 슬롯 업데이트
        result = updateDiceSlot(data);
        break;
      case 'createUser':
        // createUser 함수는 없으므로, 필요 시 추가해야 합니다.
        // result = createUserData(data); 
        throw new Error('createUser action is not yet implemented.');
      default:
        result = { status: 'error', message: 'Invalid action' };
        break;
    }
    return createJsonResponse(result, null); // POST는 일반적으로 JSONP를 사용하지 않습니다.

  } catch (error) {
    const errorResponse = { status: 'error', message: error.toString(), stack: error.stack };
    return createJsonResponse(errorResponse, null);
  }
}

/**
 * [신규] JSON 또는 JSONP 형식으로 응답을 생성하는 헬퍼 함수
 * @param {Object} data - 응답으로 보낼 JavaScript 객체
 * @param {string|null} callback - JSONP 콜백 함수 이름
 * @returns {ContentService.TextOutput} - 최종 응답 객체
 */
function createJsonResponse(data, callback) {
  const jsonString = JSON.stringify(data);
  if (callback) {
    return ContentService.createTextOutput(`${callback}(${jsonString})`)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService.createTextOutput(jsonString)
    .setMimeType(ContentService.MimeType.JSON);
}

// [개선] 데이터 로직만 처리하고 순수 객체를 반환하도록 수정
function loadUserData(userId) {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.USER_DATA);
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  // ID_No 열(첫 번째 열)에서 사용자 ID 찾기
  const userIndex = data.findIndex((row, index) => {
    if (index === 0) return false; // 헤더 행 제외
    return String(row[0]) === String(userId);
  });

  if (userIndex > 0) {
    const userData = {};
    headers.forEach((header, index) => {
      userData[header] = data[userIndex][index];
    });
    
    // JavaScript에서 사용하는 필드명으로 매핑
    userData['User_Name'] = userData['User_Name'] || '';
    userData['Roll_Count'] = userData['Roll_Count'] || 0;
    userData['Roll_Tri'] = userData['Roll_Tri'] || 0;
    userData['Roll_Str'] = userData['Roll_Str'] || 0;
    userData['Roll_Dou'] = userData['Roll_Dou'] || 0;
    userData['Roll_Sum'] = userData['Roll_Sum'] || 0;
    userData['Initial_Date'] = userData['Initial_Date'] || '';
    userData['Last_Date'] = userData['Last_Date'] || '';
    userData['Coin_Count'] = userData['Coin_Count'] || 0;
    userData['IsBattle'] = userData['IsBattle'] || false;
    
    return { status: 'success', data: userData };
  } else {
    return { status: 'not_found' };
  }
}

// [수정] 데이터 매핑을 HTML에서 사용하는 필드명에 맞게 수정
function updateUserData(data) {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.USER_DATA);
  const sheetData = sheet.getDataRange().getValues();
  const userIndex = sheetData.findIndex((row, index) => {
    if (index === 0) return false; // 헤더 행 제외
    return String(row[0]) === String(data.userId);
  });

  if (userIndex > 0) {
    const rowIndex = userIndex + 1;
    // [성능 최적화] 한 번에 여러 셀을 수정할 경우, 한 행을 통째로 읽고 수정한 뒤 한번에 쓰는 것이 빠릅니다.
    const rowData = sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    // 실제 스프레드시트 열 구조에 맞춤: ID_No(A), User_Name(B), URL(C), Roll_Count(D), Roll_Tri(E), Roll_Str(F), Roll_Dou(G), Roll_Sum(H), Initial_Date(I), Last_Date(J), Coin_Count(K), IsBattle(L)
    if (data.cumulativeScore !== undefined) rowData[7] = parseInt(data.cumulativeScore);  // H열 (Roll_Sum)
    if (data.rollCount !== undefined) rowData[3] = parseInt(data.rollCount);            // D열 (Roll_Count)
    if (data.rollTri !== undefined) rowData[4] = parseInt(data.rollTri);                // E열 (Roll_Tri)
    if (data.rollStr !== undefined) rowData[5] = parseInt(data.rollStr);                // F열 (Roll_Str)
    if (data.rollDou !== undefined) rowData[6] = parseInt(data.rollDou);                // G열 (Roll_Dou)
    if (data.coinCount !== undefined) rowData[10] = parseInt(data.coinCount);           // K열 (Coin_Count)
    if (data.initialDate && !rowData[8]) rowData[8] = data.initialDate;                // I열 (Initial_Date)
    if (data.lastDate !== undefined) rowData[9] = data.lastDate;                       // J열 (Last_Date)
    
    // 현재 시간으로 Last_Date 자동 업데이트
    if (!data.lastDate) {
      rowData[9] = formatDateForScript(new Date());
    }
    
    // 기존 필드명 지원 (하위 호환성)
    if (data.Roll_Count !== undefined) rowData[3] = parseInt(data.Roll_Count);
    if (data.Roll_Tri !== undefined) rowData[4] = parseInt(data.Roll_Tri);
    if (data.Roll_Str !== undefined) rowData[5] = parseInt(data.Roll_Str);
    if (data.Roll_Dou !== undefined) rowData[6] = parseInt(data.Roll_Dou);
    if (data.Roll_Sum !== undefined) rowData[7] = parseInt(data.Roll_Sum);
    if (data.Coin_Count !== undefined) rowData[10] = parseInt(data.Coin_Count);

    // 수정된 행 데이터를 시트에 한번에 쓰기
    sheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
    
    return { status: 'success' };
  } else {
    return { status: 'error', message: 'User not found' };
  }
}

// [개선] 데이터 로직만 처리하고 순수 객체를 반환하도록 수정
function loadDiceSettings(userId) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const data = diceSheet.getDataRange().getValues();
    const headers = data[0];
    const userIndex = data.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(userId);
    });

    if (userIndex > 0) {
      const userData = {};
      headers.forEach((header, index) => {
        userData[header] = data[userIndex][index];
      });
      return { status: 'success', data: userData };
    } else {
      return { status: 'not_found' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 기본값 반환
    console.log('DiceSetting sheet not found, returning default values');
    return { 
      status: 'success', 
      data: {
        Roll_Enable: 3,
        Dice_S1: 1,
        Dice_S2: 2,
        Dice_S3: 3,
        Dice_S4: 4,
        Dice_S5: 5,
        Dice_S6: 6
      }
    };
  }
}

// [수정] 데이터 매핑을 HTML에서 사용하는 필드명에 맞게 수정
function updateRollEnable(data) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const sheetData = diceSheet.getDataRange().getValues();
    const userIndex = sheetData.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(data.userId);
    });

    if (userIndex > 0) {
      // HTML에서 사용하는 필드명을 우선 적용
      const rollEnableValue = data.rollEnable !== undefined ? data.rollEnable : data.Roll_Enable;
      diceSheet.getRange(userIndex + 1, 2).setValue(parseInt(rollEnableValue)); // B열 (Roll_Enable)
      return { status: 'success' };
    } else {
      return { status: 'error', message: 'User not found' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 무시
    console.log('DiceSetting sheet not found, skipping update');
    return { status: 'success' };
  }
}

/**
 * [신규] Google Apps Script에서 날짜를 포맷하는 헬퍼 함수
 */
function formatDateForScript(date) {
  const year = date.getFullYear().toString().slice(-2);
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  const hours = date.getHours();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const hour12 = (hours % 12 || 12).toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  const seconds = date.getSeconds().toString().padStart(2, '0');
  
  return `${year}.${month}.${day} ${ampm} ${hour12}:${minutes}:${seconds}`;
}

/**
 * [신규] 주사위 슬롯 설정을 업데이트하는 함수
 * Page2에서 사용하는 S1-S6 슬롯의 주사위 값을 업데이트
 */
function updateDiceSlot(data) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const sheetData = diceSheet.getDataRange().getValues();
    const userIndex = sheetData.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(data.userId);
    });

    if (userIndex > 0) {
      const rowIndex = userIndex + 1;
      const rowData = diceSheet.getRange(rowIndex, 1, 1, diceSheet.getLastColumn()).getValues()[0];
      
      // S1~S6 슬롯 데이터 업데이트 (C열~H열로 가정)
      if (data.Dice_S1 !== undefined) rowData[2] = data.Dice_S1; // C열
      if (data.Dice_S2 !== undefined) rowData[3] = data.Dice_S2; // D열
      if (data.Dice_S3 !== undefined) rowData[4] = data.Dice_S3; // E열
      if (data.Dice_S4 !== undefined) rowData[5] = data.Dice_S4; // F열
      if (data.Dice_S5 !== undefined) rowData[6] = data.Dice_S5; // G열
      if (data.Dice_S6 !== undefined) rowData[7] = data.Dice_S6; // H열
      
      // 수정된 행 데이터를 시트에 한번에 쓰기
      diceSheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
      
      return { status: 'success' };
    } else {
      return { status: 'error', message: 'User not found in DiceSetting sheet' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 무시
    console.log('DiceSetting sheet not found, skipping dice slot update');
    return { status: 'success' };
  }
}