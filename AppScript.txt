// [개선] 유지보수를 위해 스프레드시트 ID와 시트 이름을 상수로 관리합니다.
const SPREADSHEET_ID = '1Ke5jewImhcCk_oHh0kLH3qr99WEGamnDqPmflnCdgQU';
const SHEET_NAMES = {
  USER_DATA: 'UserData',
  DICE_SETTING: 'DiceSetting'
};

// [개선] GET 요청을 처리하는 중앙 라우터 역할을 합니다.
function doGet(e) {
  try {
    const action = e.parameter.action;
    const callback = e.parameter.callback;
    let result;

    switch (action) {
      case 'loadUser':
        result = loadUserData(e.parameter.userId);
        break;
      case 'updateUser': // GET 요청으로 update를 하는 것은 권장되지 않지만, 기존 로직을 유지합니다.
        result = updateUserData(e.parameter);
        break;
      case 'loadDiceSettings':
        result = loadDiceSettings(e.parameter.userId);
        break;
      case 'updateRollEnable': // GET 요청으로 update를 하는 것은 권장되지 않지만, 기존 로직을 유지합니다.
        result = updateRollEnable(e.parameter);
        break;
      case 'updateDiceSlot': // 새로운 액션 추가 - 주사위 슬롯 업데이트
        result = updateDiceSlot(e.parameter);
        break;
      default:
        // 유효하지 않은 action일 경우, 에러 객체를 생성합니다.
        result = { status: 'error', message: 'Invalid action' };
        break;
    }
    
    // [개선] JSON / JSONP 응답 처리를 함수로 분리하여 중복을 제거합니다.
    return createJsonResponse(result, callback);

  } catch (error) {
    const errorResponse = { status: 'error', message: error.toString(), stack: error.stack };
    return createJsonResponse(errorResponse, e.parameter.callback);
  }
}

// [개선] POST 요청을 처리하는 중앙 라우터 역할을 합니다.
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    let result;

    switch (data.action) {
      case 'loadUser':
        result = loadUserData(data.userId);
        break;
      case 'updateUser':
        result = updateUserData(data);
        break;
      case 'loadDiceSettings':
        result = loadDiceSettings(data.userId);
        break;
      case 'updateRollEnable':
        result = updateRollEnable(data);
        break;
      case 'updateDiceSlot': // 새로운 액션 추가 - 주사위 슬롯 업데이트
        result = updateDiceSlot(data);
        break;
      case 'createUser':
        // createUser 함수는 없으므로, 필요 시 추가해야 합니다.
        // result = createUserData(data); 
        throw new Error('createUser action is not yet implemented.');
      default:
        result = { status: 'error', message: 'Invalid action' };
        break;
    }
    return createJsonResponse(result, null); // POST는 일반적으로 JSONP를 사용하지 않습니다.

  } catch (error) {
    const errorResponse = { status: 'error', message: error.toString(), stack: error.stack };
    return createJsonResponse(errorResponse, null);
  }
}

/**
 * [신규] JSON 또는 JSONP 형식으로 응답을 생성하는 헬퍼 함수
 * @param {Object} data - 응답으로 보낼 JavaScript 객체
 * @param {string|null} callback - JSONP 콜백 함수 이름
 * @returns {ContentService.TextOutput} - 최종 응답 객체
 */
function createJsonResponse(data, callback) {
  const jsonString = JSON.stringify(data);
  if (callback) {
    return ContentService.createTextOutput(`${callback}(${jsonString})`)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService.createTextOutput(jsonString)
    .setMimeType(ContentService.MimeType.JSON);
}

// [개선] 데이터 로직만 처리하고 순수 객체를 반환하도록 수정
function loadUserData(userId) {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.USER_DATA);
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  // ID_No 열(첫 번째 열)에서 사용자 ID 찾기
  const userIndex = data.findIndex((row, index) => {
    if (index === 0) return false; // 헤더 행 제외
    return String(row[0]) === String(userId);
  });

  if (userIndex > 0) {
    const userData = {};
    headers.forEach((header, index) => {
      userData[header] = data[userIndex][index];
    });
    
    // JavaScript에서 사용하는 필드명으로 매핑
    userData['User_Name'] = userData['User_Name'] || '';
    userData['Roll_Count'] = userData['Roll_Count'] || 0;
    userData['Roll_Tri'] = userData['Roll_Tri'] || 0;
    userData['Roll_Str'] = userData['Roll_Str'] || 0;
    userData['Roll_Dou'] = userData['Roll_Dou'] || 0;
    userData['Roll_Sum'] = userData['Roll_Sum'] || 0;
    userData['Initial_Date'] = userData['Initial_Date'] || '';
    userData['Last_Date'] = userData['Last_Date'] || '';
    userData['Coin_Count'] = userData['Coin_Count'] || 0;
    userData['IsBattle'] = userData['IsBattle'] || false;
    
    return { status: 'success', data: userData };
  } else {
    return { status: 'not_found' };
  }
}

// [수정] 데이터 매핑을 HTML에서 사용하는 필드명에 맞게 수정
function updateUserData(data) {
  try {
    // 디버깅을 위해 받은 데이터를 로그로 출력
    console.log('updateUserData received data:', JSON.stringify(data));
    
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.USER_DATA);
    const sheetData = sheet.getDataRange().getValues();
    
    // 헤더 정보 출력
    console.log('Sheet headers:', JSON.stringify(sheetData[0]));
    console.log('Total columns in sheet:', sheet.getLastColumn());
  
  const userIndex = sheetData.findIndex((row, index) => {
    if (index === 0) return false; // 헤더 행 제외
    return String(row[0]) === String(data.userId);
  });

  if (userIndex > 0) {
    const rowIndex = userIndex + 1;
    // [성능 최적화] 한 번에 여러 셀을 수정할 경우, 한 행을 통째로 읽고 수정한 뒤 한번에 쓰는 것이 빠릅니다.
    const rowData = sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn()).getValues()[0];
    const headers = sheetData[0];
    
    // 동적 헤더 인덱스 찾기
    const rollSumIndex = headers.findIndex(header => header === 'Roll_Sum');
    const rollCountIndex = headers.findIndex(header => header === 'Roll_Count');
    const rollTriIndex = headers.findIndex(header => header === 'Roll_Tri');
    const rollStrIndex = headers.findIndex(header => header === 'Roll_Str');
    const rollDouIndex = headers.findIndex(header => header === 'Roll_Dou');
    const coinCountIndex = headers.findIndex(header => header === 'Coin_Count');
    const initialDateIndex = headers.findIndex(header => header === 'Initial_Date');
    const lastDateIndex = headers.findIndex(header => header === 'Last_Date');
    
    console.log('Column indices - Roll_Sum:', rollSumIndex, 'Roll_Count:', rollCountIndex);
    
    // 업데이트 전 데이터 출력
    console.log('Before update - rowData:', JSON.stringify(rowData));
    
    // 동적 인덱스를 사용한 업데이트
    if (data.cumulativeScore !== undefined && rollSumIndex >= 0) {
      console.log('Updating cumulativeScore from', rowData[rollSumIndex], 'to', parseInt(data.cumulativeScore));
      rowData[rollSumIndex] = parseInt(data.cumulativeScore);
    }
    if (data.rollCount !== undefined && rollCountIndex >= 0) {
      console.log('Updating rollCount from', rowData[rollCountIndex], 'to', parseInt(data.rollCount));
      rowData[rollCountIndex] = parseInt(data.rollCount);
    }
    if (data.rollTri !== undefined && rollTriIndex >= 0) {
      console.log('Updating rollTri from', rowData[rollTriIndex], 'to', parseInt(data.rollTri));
      rowData[rollTriIndex] = parseInt(data.rollTri);
    }
    if (data.rollStr !== undefined && rollStrIndex >= 0) {
      console.log('Updating rollStr from', rowData[rollStrIndex], 'to', parseInt(data.rollStr));
      rowData[rollStrIndex] = parseInt(data.rollStr);
    }
    if (data.rollDou !== undefined && rollDouIndex >= 0) {
      console.log('Updating rollDou from', rowData[rollDouIndex], 'to', parseInt(data.rollDou));
      rowData[rollDouIndex] = parseInt(data.rollDou);
    }
    if (data.coinCount !== undefined && coinCountIndex >= 0) {
      console.log('Updating coinCount from', rowData[coinCountIndex], 'to', parseInt(data.coinCount));
      rowData[coinCountIndex] = parseInt(data.coinCount);
    }
    if (data.initialDate && initialDateIndex >= 0 && !rowData[initialDateIndex]) rowData[initialDateIndex] = data.initialDate;
    if (data.lastDate !== undefined && lastDateIndex >= 0) rowData[lastDateIndex] = data.lastDate;
    
    // 현재 시간으로 Last_Date 자동 업데이트
    if (!data.lastDate && lastDateIndex >= 0) {
      rowData[lastDateIndex] = formatDateForScript(new Date());
    }
    
    // 기존 필드명 지원 (하위 호환성)
    if (data.Roll_Count !== undefined && rollCountIndex >= 0) rowData[rollCountIndex] = parseInt(data.Roll_Count);
    if (data.Roll_Tri !== undefined && rollTriIndex >= 0) rowData[rollTriIndex] = parseInt(data.Roll_Tri);
    if (data.Roll_Str !== undefined && rollStrIndex >= 0) rowData[rollStrIndex] = parseInt(data.Roll_Str);
    if (data.Roll_Dou !== undefined && rollDouIndex >= 0) rowData[rollDouIndex] = parseInt(data.Roll_Dou);
    if (data.Roll_Sum !== undefined && rollSumIndex >= 0) {
      console.log('Updating Roll_Sum from', rowData[rollSumIndex], 'to', parseInt(data.Roll_Sum));
      rowData[rollSumIndex] = parseInt(data.Roll_Sum);
    }
    if (data.Coin_Count !== undefined && coinCountIndex >= 0) rowData[coinCountIndex] = parseInt(data.Coin_Count);
    
    // 업데이트 후 데이터 출력
    console.log('After update - rowData:', JSON.stringify(rowData));

    // 수정된 행 데이터를 시트에 한번에 쓰기
    sheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
    
    return { status: 'success' };
  } else {
    console.log('User not found with ID:', data.userId);
    return { status: 'error', message: `User not found with ID: ${data.userId}` };
  }
  } catch (error) {
    console.error('Error in updateUserData:', error);
    return { status: 'error', message: error.toString(), stack: error.stack };
  }
}

// [개선] 데이터 로직만 처리하고 순수 객체를 반환하도록 수정
function loadDiceSettings(userId) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const data = diceSheet.getDataRange().getValues();
    const headers = data[0];
    const userIndex = data.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(userId);
    });

    if (userIndex > 0) {
      const userData = {};
      headers.forEach((header, index) => {
        userData[header] = data[userIndex][index];
      });
      return { status: 'success', data: userData };
    } else {
      return { status: 'not_found' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 기본값 반환
    console.log('DiceSetting sheet not found, returning default values');
    return { 
      status: 'success', 
      data: {
        Roll_Enable: 3,
        Dice_S1: 1,
        Dice_S2: 2,
        Dice_S3: 3,
        Dice_S4: 4,
        Dice_S5: 5,
        Dice_S6: 6
      }
    };
  }
}

// [수정] 데이터 매핑을 HTML에서 사용하는 필드명에 맞게 수정
function updateRollEnable(data) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const sheetData = diceSheet.getDataRange().getValues();
    const userIndex = sheetData.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(data.userId);
    });

    if (userIndex > 0) {
      // HTML에서 사용하는 필드명을 우선 적용
      // DiceSetting 구조: User_ID(A:0), User_Name(B:1), Roll_Enable(C:2), Dice_S1(D:3), Dice_S2(E:4), Dice_S3(F:5), Dice_S4(G:6), Dice_S5(H:7), Dice_S6(I:8)
      const rollEnableValue = data.rollEnable !== undefined ? data.rollEnable : data.Roll_Enable;
      diceSheet.getRange(userIndex + 1, 3).setValue(parseInt(rollEnableValue)); // C열(2) (Roll_Enable)
      return { status: 'success' };
    } else {
      return { status: 'error', message: 'User not found' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 무시
    console.log('DiceSetting sheet not found, skipping update');
    return { status: 'success' };
  }
}

/**
 * [신규] Google Apps Script에서 날짜를 포맷하는 헬퍼 함수
 */
function formatDateForScript(date) {
  const year = date.getFullYear().toString().slice(-2);
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  const hours = date.getHours();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const hour12 = (hours % 12 || 12).toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  const seconds = date.getSeconds().toString().padStart(2, '0');
  
  return `${year}.${month}.${day} ${ampm} ${hour12}:${minutes}:${seconds}`;
}

/**
 * [신규] 주사위 슬롯 설정을 업데이트하는 함수
 * Page2에서 사용하는 S1-S6 슬롯의 주사위 값을 업데이트
 */
function updateDiceSlot(data) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const sheetData = diceSheet.getDataRange().getValues();
    const userIndex = sheetData.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(data.userId);
    });

    if (userIndex > 0) {
      const rowIndex = userIndex + 1;
      const rowData = diceSheet.getRange(rowIndex, 1, 1, diceSheet.getLastColumn()).getValues()[0];
      
      // DiceSetting 구조: User_ID(A:0), User_Name(B:1), Roll_Enable(C:2), Dice_S1(D:3), Dice_S2(E:4), Dice_S3(F:5), Dice_S4(G:6), Dice_S5(H:7), Dice_S6(I:8)
      if (data.Dice_S1 !== undefined) rowData[3] = parseInt(data.Dice_S1); // D열(3)
      if (data.Dice_S2 !== undefined) rowData[4] = parseInt(data.Dice_S2); // E열(4)
      if (data.Dice_S3 !== undefined) rowData[5] = parseInt(data.Dice_S3); // F열(5)
      if (data.Dice_S4 !== undefined) rowData[6] = parseInt(data.Dice_S4); // G열(6)
      if (data.Dice_S5 !== undefined) rowData[7] = parseInt(data.Dice_S5); // H열(7)
      if (data.Dice_S6 !== undefined) rowData[8] = parseInt(data.Dice_S6); // I열(8)
      
      // 수정된 행 데이터를 시트에 한번에 쓰기
      diceSheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
      
      return { status: 'success' };
    } else {
      return { status: 'error', message: 'User not found in DiceSetting sheet' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 무시
    console.log('DiceSetting sheet not found, skipping dice slot update');
    return { status: 'success' };
  }
}