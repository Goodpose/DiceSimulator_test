// [개선] 유지보수를 위해 스프레드시트 ID와 시트 이름을 상수로 관리합니다.
const SPREADSHEET_ID = '1Ke5jewImhcCk_oHh0kLH3qr99WEGamnDqPmflnCdgQU';
const SHEET_NAMES = {
  USER_DATA: 'UserData',
  DICE_SETTING: 'DiceSetting'
};

// [개선] GET 요청을 처리하는 중앙 라우터 역할을 합니다.
function doGet(e) {
  try {
    const action = e.parameter.action;
    const callback = e.parameter.callback;
    let result;

    switch (action) {
      case 'loadUser':
        result = loadUserData(e.parameter.userId);
        break;
      case 'updateUser': // GET 요청으로 update를 하는 것은 권장되지 않지만, 기존 로직을 유지합니다.
        result = updateUserData(e.parameter);
        break;
      case 'loadDiceSettings':
        result = loadDiceSettings(e.parameter.userId);
        break;
      case 'updateRollEnable': // GET 요청으로 update를 하는 것은 권장되지 않지만, 기존 로직을 유지합니다.
        result = updateRollEnable(e.parameter);
        break;
      case 'updateDiceSlot': // 새로운 액션 추가 - 주사위 슬롯 업데이트
        result = updateDiceSlot(e.parameter);
        break;
      default:
        // 유효하지 않은 action일 경우, 에러 객체를 생성합니다.
        result = { status: 'error', message: 'Invalid action' };
        break;
    }
    
    // [개선] JSON / JSONP 응답 처리를 함수로 분리하여 중복을 제거합니다.
    return createJsonResponse(result, callback);

  } catch (error) {
    const errorResponse = { status: 'error', message: error.toString(), stack: error.stack };
    return createJsonResponse(errorResponse, e.parameter.callback);
  }
}

// [개선] POST 요청을 처리하는 중앙 라우터 역할을 합니다.
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    let result;

    switch (data.action) {
      case 'loadUser':
        result = loadUserData(data.userId);
        break;
      case 'updateUser':
        result = updateUserData(data);
        break;
      case 'loadDiceSettings':
        result = loadDiceSettings(data.userId);
        break;
      case 'updateRollEnable':
        result = updateRollEnable(data);
        break;
      case 'updateDiceSlot': // 새로운 액션 추가 - 주사위 슬롯 업데이트
        result = updateDiceSlot(data);
        break;
      case 'createUser':
        // createUser 함수는 없으므로, 필요 시 추가해야 합니다.
        // result = createUserData(data); 
        throw new Error('createUser action is not yet implemented.');
      default:
        result = { status: 'error', message: 'Invalid action' };
        break;
    }
    return createJsonResponse(result, null); // POST는 일반적으로 JSONP를 사용하지 않습니다.

  } catch (error) {
    const errorResponse = { status: 'error', message: error.toString(), stack: error.stack };
    return createJsonResponse(errorResponse, null);
  }
}

/**
 * [신규] JSON 또는 JSONP 형식으로 응답을 생성하는 헬퍼 함수
 * @param {Object} data - 응답으로 보낼 JavaScript 객체
 * @param {string|null} callback - JSONP 콜백 함수 이름
 * @returns {ContentService.TextOutput} - 최종 응답 객체
 */
function createJsonResponse(data, callback) {
  const jsonString = JSON.stringify(data);
  if (callback) {
    return ContentService.createTextOutput(`${callback}(${jsonString})`)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService.createTextOutput(jsonString)
    .setMimeType(ContentService.MimeType.JSON);
}

// [개선] 데이터 로직만 처리하고 순수 객체를 반환하도록 수정
function loadUserData(userId) {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.USER_DATA);
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  // ID_No 열(첫 번째 열)에서 사용자 ID 찾기
  const userIndex = data.findIndex((row, index) => {
    if (index === 0) return false; // 헤더 행 제외
    return String(row[0]) === String(userId);
  });

  if (userIndex > 0) {
    const userData = {};
    headers.forEach((header, index) => {
      userData[header] = data[userIndex][index];
    });
    
    // JavaScript에서 사용하는 필드명으로 매핑
    userData['User_Name'] = userData['User_Name'] || '';
    userData['Roll_Count'] = userData['Roll_Count'] || 0;
    userData['Roll_Tri'] = userData['Roll_Tri'] || 0;
    userData['Roll_Str'] = userData['Roll_Str'] || 0;
    userData['Roll_Dou'] = userData['Roll_Dou'] || 0;
    userData['Roll_Sum'] = userData['Roll_Sum'] || 0;
    userData['Initial_Date'] = userData['Initial_Date'] || '';
    userData['Last_Date'] = userData['Last_Date'] || '';
    userData['Coin_Count'] = userData['Coin_Count'] || 0;
    userData['IsBattle'] = userData['IsBattle'] || false;
    
    return { status: 'success', data: userData };
  } else {
    return { status: 'not_found' };
  }
}

// [수정] 데이터 매핑을 HTML에서 사용하는 필드명에 맞게 수정
function updateUserData(data) {
  try {
    // 디버깅을 위해 받은 데이터를 로그로 출력
    console.log('updateUserData received data:', JSON.stringify(data));
    
    const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.USER_DATA);
    const sheetData = sheet.getDataRange().getValues();
    
    // 헤더 정보 출력
    console.log('Sheet headers:', JSON.stringify(sheetData[0]));
    console.log('Total columns in sheet:', sheet.getLastColumn());
  
  const userIndex = sheetData.findIndex((row, index) => {
    if (index === 0) return false; // 헤더 행 제외
    return String(row[0]) === String(data.userId);
  });

  if (userIndex > 0) {
    const rowIndex = userIndex + 1;
    // [성능 최적화] 한 번에 여러 셀을 수정할 경우, 한 행을 통째로 읽고 수정한 뒤 한번에 쓰는 것이 빠릅니다.
    const rowData = sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn()).getValues()[0];
    const headers = sheetData[0];
    
    // 고정 열 인덱스 사용: A(0) B(1) C(2) D(3) E(4) F(5) G(6) H(7) I(8) J(9) K(10) L(11)
    // ID_No(0) User_Name(1) URL(2) Roll_Count(3) Roll_Tri(4) Roll_Str(5) Roll_Dou(6) Roll_Sum(7) Initial_Date(8) Last_Date(9) Coin_Count(10) IsBattle(11)
    console.log('Using fixed column indices for data update');
    
    // 업데이트 전 데이터 출력
    console.log('Before update - rowData:', JSON.stringify(rowData));
    
    // Roll_Sum 업데이트 (H열, 인덱스 7)
    if (data.cumulativeScore !== undefined) {
      console.log('=== Roll_Sum Update Debug ===');
      console.log('data.cumulativeScore:', data.cumulativeScore, typeof data.cumulativeScore);
      console.log('rowData[7] before:', rowData[7], typeof rowData[7]);
      console.log('parseInt(data.cumulativeScore):', parseInt(data.cumulativeScore));
      
      rowData[7] = parseInt(data.cumulativeScore);
      
      console.log('rowData[7] after:', rowData[7], typeof rowData[7]);
      console.log('=== End Roll_Sum Debug ===');
    }
    if (data.rollCount !== undefined) {
      console.log('Updating rollCount from', rowData[3], 'to', parseInt(data.rollCount));
      rowData[3] = parseInt(data.rollCount);  // D열(3) Roll_Count
    }
    if (data.rollTri !== undefined) {
      console.log('Updating rollTri from', rowData[4], 'to', parseInt(data.rollTri));
      rowData[4] = parseInt(data.rollTri);    // E열(4) Roll_Tri
    }
    if (data.rollStr !== undefined) {
      console.log('Updating rollStr from', rowData[5], 'to', parseInt(data.rollStr));
      rowData[5] = parseInt(data.rollStr);    // F열(5) Roll_Str
    }
    if (data.rollDou !== undefined) {
      console.log('Updating rollDou from', rowData[6], 'to', parseInt(data.rollDou));
      rowData[6] = parseInt(data.rollDou);    // G열(6) Roll_Dou
    }
    if (data.coinCount !== undefined) {
      console.log('Updating coinCount from', rowData[10], 'to', parseInt(data.coinCount));
      rowData[10] = parseInt(data.coinCount); // K열(10) Coin_Count
    }
    if (data.initialDate && !rowData[8]) rowData[8] = data.initialDate;     // I열(8) Initial_Date
    if (data.lastDate !== undefined) rowData[9] = data.lastDate;            // J열(9) Last_Date
    
    // 현재 시간으로 Last_Date 자동 업데이트
    if (!data.lastDate) {
      rowData[9] = formatDateForScript(new Date());  // J열(9) Last_Date
    }
    
    // 기존 필드명 지원 (하위 호환성) - 모두 고정 인덱스 사용
    if (data.Roll_Count !== undefined) rowData[3] = parseInt(data.Roll_Count);   // D열(3)
    if (data.Roll_Tri !== undefined) rowData[4] = parseInt(data.Roll_Tri);       // E열(4)
    if (data.Roll_Str !== undefined) rowData[5] = parseInt(data.Roll_Str);       // F열(5)
    if (data.Roll_Dou !== undefined) rowData[6] = parseInt(data.Roll_Dou);       // G열(6)
    if (data.Roll_Sum !== undefined) {
      console.log('=== Roll_Sum (legacy) Update Debug ===');
      console.log('data.Roll_Sum:', data.Roll_Sum, typeof data.Roll_Sum);
      console.log('rowData[7] before legacy update:', rowData[7], typeof rowData[7]);
      console.log('parseInt(data.Roll_Sum):', parseInt(data.Roll_Sum));
      
      rowData[7] = parseInt(data.Roll_Sum);  // H열(7)
      
      console.log('rowData[7] after legacy update:', rowData[7], typeof rowData[7]);
      console.log('=== End Roll_Sum (legacy) Debug ===');
    }
    if (data.Coin_Count !== undefined) rowData[10] = parseInt(data.Coin_Count);  // K열(10)
    
    // 업데이트 후 데이터 출력
    console.log('After update - rowData:', JSON.stringify(rowData));

    // 수정된 행 데이터를 시트에 한번에 쓰기
    console.log('Writing to sheet - rowIndex:', rowIndex, 'rowData.length:', rowData.length);
    console.log('Final rowData before write:', JSON.stringify(rowData));
    console.log('Specifically rowData[7] (Roll_Sum):', rowData[7]);
    
    sheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
    
    // 쓰기 후 확인
    const writtenData = sheet.getRange(rowIndex, 1, 1, rowData.length).getValues()[0];
    console.log('Data after write to sheet:', JSON.stringify(writtenData));
    console.log('Specifically written data[7] (Roll_Sum):', writtenData[7]);
    
    return { status: 'success' };
  } else {
    console.log('User not found with ID:', data.userId);
    return { status: 'error', message: `User not found with ID: ${data.userId}` };
  }
  } catch (error) {
    console.error('Error in updateUserData:', error);
    return { status: 'error', message: error.toString(), stack: error.stack };
  }
}

// [개선] 데이터 로직만 처리하고 순수 객체를 반환하도록 수정
function loadDiceSettings(userId) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const data = diceSheet.getDataRange().getValues();
    const headers = data[0];
    const userIndex = data.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(userId);
    });

    if (userIndex > 0) {
      const userData = {};
      headers.forEach((header, index) => {
        userData[header] = data[userIndex][index];
      });
      return { status: 'success', data: userData };
    } else {
      return { status: 'not_found' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 기본값 반환
    console.log('DiceSetting sheet not found, returning default values');
    return { 
      status: 'success', 
      data: {
        Roll_Enable: 3,
        Dice_S1: 1,
        Dice_S2: 2,
        Dice_S3: 3,
        Dice_S4: 4,
        Dice_S5: 5,
        Dice_S6: 6
      }
    };
  }
}

// [수정] 데이터 매핑을 HTML에서 사용하는 필드명에 맞게 수정
function updateRollEnable(data) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const sheetData = diceSheet.getDataRange().getValues();
    const userIndex = sheetData.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(data.userId);
    });

    if (userIndex > 0) {
      // HTML에서 사용하는 필드명을 우선 적용
      // DiceSetting 구조: User_ID(A:0), User_Name(B:1), Roll_Enable(C:2), Dice_S1(D:3), Dice_S2(E:4), Dice_S3(F:5), Dice_S4(G:6), Dice_S5(H:7), Dice_S6(I:8)
      const rollEnableValue = data.rollEnable !== undefined ? data.rollEnable : data.Roll_Enable;
      diceSheet.getRange(userIndex + 1, 3).setValue(parseInt(rollEnableValue)); // C열(2) (Roll_Enable)
      return { status: 'success' };
    } else {
      return { status: 'error', message: 'User not found' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 무시
    console.log('DiceSetting sheet not found, skipping update');
    return { status: 'success' };
  }
}

/**
 * [신규] Google Apps Script에서 날짜를 포맷하는 헬퍼 함수
 */
function formatDateForScript(date) {
  const year = date.getFullYear().toString().slice(-2);
  const month = (date.getMonth() + 1).toString().padStart(2, '0');
  const day = date.getDate().toString().padStart(2, '0');
  const hours = date.getHours();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  const hour12 = (hours % 12 || 12).toString().padStart(2, '0');
  const minutes = date.getMinutes().toString().padStart(2, '0');
  const seconds = date.getSeconds().toString().padStart(2, '0');
  
  return `${year}.${month}.${day} ${ampm} ${hour12}:${minutes}:${seconds}`;
}

/**
 * [신규] 주사위 슬롯 설정을 업데이트하는 함수
 * Page2에서 사용하는 S1-S6 슬롯의 주사위 값을 업데이트
 */
function updateDiceSlot(data) {
  try {
    const diceSheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(SHEET_NAMES.DICE_SETTING);
    const sheetData = diceSheet.getDataRange().getValues();
    const userIndex = sheetData.findIndex((row, index) => {
      if (index === 0) return false; // 헤더 행 제외
      return String(row[0]) === String(data.userId);
    });

    if (userIndex > 0) {
      const rowIndex = userIndex + 1;
      const rowData = diceSheet.getRange(rowIndex, 1, 1, diceSheet.getLastColumn()).getValues()[0];
      
      // DiceSetting 구조: User_ID(A:0), User_Name(B:1), Roll_Enable(C:2), Dice_S1(D:3), Dice_S2(E:4), Dice_S3(F:5), Dice_S4(G:6), Dice_S5(H:7), Dice_S6(I:8)
      if (data.Dice_S1 !== undefined) rowData[3] = parseInt(data.Dice_S1); // D열(3)
      if (data.Dice_S2 !== undefined) rowData[4] = parseInt(data.Dice_S2); // E열(4)
      if (data.Dice_S3 !== undefined) rowData[5] = parseInt(data.Dice_S3); // F열(5)
      if (data.Dice_S4 !== undefined) rowData[6] = parseInt(data.Dice_S4); // G열(6)
      if (data.Dice_S5 !== undefined) rowData[7] = parseInt(data.Dice_S5); // H열(7)
      if (data.Dice_S6 !== undefined) rowData[8] = parseInt(data.Dice_S6); // I열(8)
      
      // 수정된 행 데이터를 시트에 한번에 쓰기
      diceSheet.getRange(rowIndex, 1, 1, rowData.length).setValues([rowData]);
      
      return { status: 'success' };
    } else {
      return { status: 'error', message: 'User not found in DiceSetting sheet' };
    }
  } catch (error) {
    // DiceSetting 시트가 없는 경우 무시
    console.log('DiceSetting sheet not found, skipping dice slot update');
    return { status: 'success' };
  }
}